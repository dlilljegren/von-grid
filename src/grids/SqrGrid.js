import * as THREE from './../../lib/three.module.js';
import {vg} from '../vg.js'
import {Cell} from './Cell.js'; 
import {Coord} from './Coord.js'; 
import {Tools} from '../utils/Tools.js'
import {AbstractGrid} from './AbstractGrid.js'; 
/*
	Graph of squares. Handles grid cell management (placement math for eg pathfinding, range, etc) and grid conversion math.
	Interface:
	type
	size - number of cells (in radius); only used if the map is generated
	cellSize
	cells - a hash so we can have sparse maps
	numCells
	extrudeSettings
	autogenerated
	cellShape
	cellGeo
	cellShapeGeo

	@author Corey Birnbaum https://github.com/vonWolfehaus/
	@author David Lilljegren
 */
export class SqrGrid extends AbstractGrid{
	 constructor(config) {
		 super(config);
		
		/*  ______________________________________________
			GRID INTERFACE:
		*/
		this.type = vg.SQR;
		
		this.autogenerated = false;

		// create base shape used for building geometry
		var verts = [];
		verts.push(new THREE.Vector3());
		verts.push(new THREE.Vector3(-this.cellSize, this.cellSize));
		verts.push(new THREE.Vector3(this.cellSize, this.cellSize));
		verts.push(new THREE.Vector3(this.cellSize, -this.cellSize));
		// copy the verts into a shape for the geometry to use
		this.cellShape = new THREE.Shape();
		this.cellShape.moveTo(-this.cellSize, -this.cellSize);
		this.cellShape.lineTo(-this.cellSize, this.cellSize);
		this.cellShape.lineTo(this.cellSize, this.cellSize);
		this.cellShape.lineTo(this.cellSize, -this.cellSize);
		this.cellShape.lineTo(-this.cellSize, -this.cellSize);

		this.cellGeo = new THREE.Geometry();
		this.cellGeo.vertices = verts;
		this.cellGeo.verticesNeedUpdate = true;

		this.cellShapeGeo = new THREE.ShapeGeometry(this.cellShape);

		/*  ______________________________________________
			PRIVATE
		*/

		this._fullCellSize = this.cellSize * 2;
		
		this._directions = Coord.sqrDirections;
		this._diagonals = [new Cell(-1, -1, 0), new Cell(-1, +1, 0),
						new Cell(+1, +1, 0), new Cell(+1, -1, 0)];
		// cached objects
		this._list = [];
		
		this._conversionVec = new THREE.Vector3();
		this._geoCache = [];
		this._matCache = [];
	}


	/*
		________________________________________________________________________
		High-level functions that the Board interfaces with (all grids implement)
	 */

	coordToPixel(coord) {
		this._vec3.x = coord.col * this._fullCellSize;
		this._vec3.y = coord.depth*this.cellHeight;
		this._vec3.z = coord.row * this._fullCellSize;
		return this._vec3;
	}

	pixelToCoord(pos) {
		const col = Math.round(pos.x / this._fullCellSize);
		const row = Math.round(pos.z / this._fullCellSize);
		const depth =0;//ToDo
		return this._coord.setRCD(row, col, depth);
	}

	getCellAt(pos) {
		var q = Math.round(pos.x / this._fullCellSize);
		var r = Math.round(pos.z / this._fullCellSize);
		this._coord.set(q, r);
		return this.cells[this.coordToHash(this._coord)];
	}

	getNeighbors(cell, diagonal, filter) {
		// always returns an array
		var i, n, l = this._directions.length;
		this._list.length = 0;
		for (i = 0; i < l; i++) {
			this._coord.copy(cell.coord);
			this._coord.add(this._directions[i]);
			n = this.cells.get(this.coordToHash(this._coord));
			if (!n || (filter && !filter(cell, n))) {
				continue;
			}
			this._list.push(n);
		}
		if (diagonal) {
			for (i = 0; i < l; i++) {
				this._coord.copy(cell);
				this._coord.add(this._diagonals[i]);
				n = this.cells.get(this.coordToHash(this._coord));
				if (!n || (filter && !filter(cell, n))) {
					continue;
				}
				this._list.push(n);
			}
		}
		return this._list;
	}



	coordToHash(cell) {
		return cell.row+this._hashDelimeter+cell.col+this._hashDelimeter+cell.depth; // s is not used in a square grid
	}

	distance(cellA, cellB) {
		var d = Math.max(Math.abs(cellA.row - cellB.row), Math.abs(cellA.col - cellB.col));
		//d += cellB.h - cellA.h; // include vertical size
		return d;
	}





	generateTilePoly(material) {
		if (!material) {
			material = new THREE.MeshBasicMaterial({color: 0x24b4ff});
		}
		var mesh = new THREE.Mesh(this.cellShapeGeo, material);
		this._vec3.set(1, 0, 0);
		mesh.rotateOnAxis(this._vec3, vg.PI/2);
		return mesh;
	}


	dispose() {
		super.dispose();
				
		this.cellShape = null;
		this.cellGeo.dispose();
		this.cellGeo = null;
		this.cellShapeGeo.dispose();
		this.cellShapeGeo = null;
		this._list = null;
		this._vec3 = null;
		this._conversionVec = null;
		this._geoCache = null;
		this._matCache = null;
	}

	/*
		Load a grid from a parsed json object.
		json = {
			extrudeSettings,
			size,
			cellSize,
			autogenerated,
			cells: [],
			materials: [
				{
					cache_id: 0,
					type: 'MeshLambertMaterial',
					color, ambient, emissive, reflectivity, refractionRatio, wrapAround,
					imgURL: url
				},
				{
					cacheId: 1, ...
				}
				...
			]
		}
	*/
	load(url, callback, scope) {
		vg.Tools.getJSON({
			url: url,
			callback: function(json) {
				this.fromJSON(json);
				callback.call(scope || null, json);
			},
			cache: false,
			scope: this
		});
	}

	fromJSON(json) {
		var i, c;
		var cells = json.cells;

		this.cells = {};
		this.numCells = 0;

		this.size = json.size;
		this.cellSize = json.cellSize;
		this._fullCellSize = this.cellSize * 2;
		this.extrudeSettings = json.extrudeSettings;
		this.autogenerated = json.autogenerated;

		for (i = 0; i < cells.length; i++) {
			c = new vg.Cell();
			c.copy(cells[i]);
			this.add(c);
		}
	}

	toJSON() {
		var json = {
			size: this.size,
			cellSize: this.cellSize,
			extrudeSettings: this.extrudeSettings,
			autogenerated: this.autogenerated
		};
		var cells = [];
		var c, k;

		for (k in this.cells) {
			c = this.cells[k];
			cells.push({
				q: c.q,
				r: c.r,
				s: c.s,
				h: c.h,
				walkable: c.walkable,
				userData: c.userData
			});
		}
		json.cells = cells;

		return json;
	}
}


